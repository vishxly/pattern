import { ComponentGroup } from "@/lib/docs/types";
import BeamEffectDemo from "../components/beam-effect";

export const beamEffectRegistry: ComponentGroup = {
  name: "beamEffectRegistry",
  title: "Beam-effect",
  description: "A React component that provides beam-effect functionality.",
  category: "components",
  components: ["Beam-effectDemo"],
  installation: {
    cliCommand:
      'npx shadcn@latest add "https://zeroui.vercel.app/r/beam-effect"',
    dependencies: ["react", "three"],
    componentPath: "components/ui/beam-effect.tsx",
    utilsCode:
      'import { ClassValue, clsx } from "clsx";\nimport { twMerge } from "tailwind-merge";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}',
  },
  props: [],
  variants: {
    basic: {
      title: "Basic Beam-effect",
      description: "A basic implementation of the Beam-effect component.",
      component: BeamEffectDemo,
      image: "/images/components/beam-effect-basic.png",
      fallbackImage:
        "/placeholder.svg?height=300&width=400&text=Basic%20Beam-effect",
      code: '"use client";\nimport { Beam-effect } from "../ui/beam-effect";\n\nexport const Beam-effectDemo = () => {\n  return (\n    <div className="w-full h-full flex items-center justify-center bg-neutral-100 dark:bg-neutral-900 p-12 rounded-xl">\n      <Beam-effect>\n        Demo Content\n      </Beam-effect>\n    </div>\n  );\n};\n\nexport default Beam-effectDemo;',
      manualCode:
        "import React, { useEffect, useRef } from 'react';\r\nimport * as THREE from 'three';\r\n\r\ntype Props = {\r\n  className?: string;\r\n  style?: React.CSSProperties;\r\n  wispDensity?: number;\r\n  dpr?: number;\r\n  mouseSmoothTime?: number;\r\n  mouseTiltStrength?: number;\r\n  horizontalBeamOffset?: number;\r\n  verticalBeamOffset?: number;\r\n  flowSpeed?: number;\r\n  verticalSizing?: number;\r\n  horizontalSizing?: number;\r\n  fogIntensity?: number;\r\n  fogScale?: number;\r\n  wispSpeed?: number;\r\n  wispIntensity?: number;\r\n  flowStrength?: number;\r\n  decay?: number;\r\n  falloffStart?: number;\r\n  fogFallSpeed?: number;\r\n  color?: string;\r\n};\r\n\r\nconst VERT = `\r\nprecision highp float;\r\nattribute vec3 position;\r\nvoid main(){\r\n  gl_Position = vec4(position, 1.0);\r\n}\r\n`;\r\n\r\nconst FRAG = `\r\n#ifdef GL_ES\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\nprecision highp float;\r\nprecision mediump int;\r\n\r\nuniform float iTime;\r\nuniform vec3 iResolution;\r\nuniform vec4 iMouse;\r\nuniform float uWispDensity;\r\nuniform float uTiltScale;\r\nuniform float uFlowTime;\r\nuniform float uFogTime;\r\nuniform float uBeamXFrac;\r\nuniform float uBeamYFrac;\r\nuniform float uFlowSpeed;\r\nuniform float uVLenFactor;\r\nuniform float uHLenFactor;\r\nuniform float uFogIntensity;\r\nuniform float uFogScale;\r\nuniform float uWSpeed;\r\nuniform float uWIntensity;\r\nuniform float uFlowStrength;\r\nuniform float uDecay;\r\nuniform float uFalloffStart;\r\nuniform float uFogFallSpeed;\r\nuniform vec3 uColor;\r\nuniform float uFade;\r\n\r\n// Core beam/flare shaping and dynamics\r\n#define PI 3.14159265359\r\n#define TWO_PI 6.28318530718\r\n#define EPS 1e-6\r\n#define EDGE_SOFT (DT_LOCAL*4.0)\r\n#define DT_LOCAL 0.0038\r\n#define TAP_RADIUS 6\r\n#define R_H 150.0\r\n#define R_V 150.0\r\n#define FLARE_HEIGHT 16.0\r\n#define FLARE_AMOUNT 8.0\r\n#define FLARE_EXP 2.0\r\n#define TOP_FADE_START 0.1\r\n#define TOP_FADE_EXP 1.0\r\n#define FLOW_PERIOD 0.5\r\n#define FLOW_SHARPNESS 1.5\r\n\r\n// Wisps (animated micro-streaks) that travel along the beam\r\n#define W_BASE_X 1.5\r\n#define W_LAYER_GAP 0.25\r\n#define W_LANES 55\r\n#define W_SIDE_DECAY 0.5\r\n#define W_HALF 0.01\r\n#define W_AA 0.15\r\n#define W_CELL 20.0\r\n#define W_SEG_MIN 0.01\r\n#define W_SEG_MAX 0.55\r\n#define W_CURVE_AMOUNT 15.0\r\n#define W_CURVE_RANGE (FLARE_HEIGHT - 3.0)\r\n#define W_BOTTOM_EXP 10.0\r\n\r\n// Volumetric fog controls\r\n#define FOG_ON 1\r\n#define FOG_CONTRAST 1.5\r\n#define FOG_SPEED_U 0.1\r\n#define FOG_SPEED_V -0.1\r\n#define FOG_OCTAVES 5\r\n#define FOG_BOTTOM_BIAS 0.8\r\n#define FOG_TILT_TO_MOUSE 0.05\r\n#define FOG_TILT_DEADZONE 0.01\r\n#define FOG_TILT_MAX_X 0.35\r\n#define FOG_TILT_SHAPE 1.5\r\n#define FOG_BEAM_MIN 0.0\r\n#define FOG_BEAM_MAX 0.75\r\n#define FOG_MASK_GAMMA 0.20\r\n#define FOG_EXPAND_SHAPE 12.2\r\n#define FOG_EDGE_MIX 0.5\r\n\r\n// Horizontal vignette for the fog volume\r\n#define HFOG_EDGE_START 0.20\r\n#define HFOG_EDGE_END 0.98\r\n#define HFOG_EDGE_GAMMA 1.4\r\n#define HFOG_Y_RADIUS 25.0\r\n#define HFOG_Y_SOFT 60.0\r\n\r\n// Beam extents and edge masking\r\n#define EDGE_X0 0.22\r\n#define EDGE_X1 0.995\r\n#define EDGE_X_GAMMA 1.25\r\n#define EDGE_LUMA_T0 0.0\r\n#define EDGE_LUMA_T1 2.0\r\n#define DITHER_STRENGTH 1.0\r\n\r\n    float g(float x){return x<=0.00031308?12.92*x:1.055*pow(x,1.0/2.4)-0.055;}\r\n    float bs(vec2 p,vec2 q,float powr){\r\n        float d=distance(p,q),f=powr*uFalloffStart,r=(f*f)/(d*d+EPS);\r\n        return powr*min(1.0,r);\r\n    }\r\n    float bsa(vec2 p,vec2 q,float powr,vec2 s){\r\n        vec2 d=p-q; float dd=(d.x*d.x)/(s.x*s.x)+(d.y*d.y)/(s.y*s.y),f=powr*uFalloffStart,r=(f*f)/(dd+EPS);\r\n        return powr*min(1.0,r);\r\n    }\r\n    float tri01(float x){float f=fract(x);return 1.0-abs(f*2.0-1.0);}\r\n    float tauWf(float t,float tmin,float tmax){float a=smoothstep(tmin,tmin+EDGE_SOFT,t),b=1.0-smoothstep(tmax-EDGE_SOFT,tmax,t);return max(0.0,a*b);} \r\n    float h21(vec2 p){p=fract(p*vec2(123.34,456.21));p+=dot(p,p+34.123);return fract(p.x*p.y);}\r\n    float vnoise(vec2 p){\r\n        vec2 i=floor(p),f=fract(p);\r\n        float a=h21(i),b=h21(i+vec2(1,0)),c=h21(i+vec2(0,1)),d=h21(i+vec2(1,1));\r\n        vec2 u=f*f*(3.0-2.0*f);\r\n        return mix(mix(a,b,u.x),mix(c,d,u.x),u.y);\r\n    }\r\n    float fbm2(vec2 p){\r\n        float v=0.0,amp=0.6; mat2 m=mat2(0.86,0.5,-0.5,0.86);\r\n        for(int i=0;i<FOG_OCTAVES;++i){v+=amp*vnoise(p); p=m*p*2.03+17.1; amp*=0.52;}\r\n        return v;\r\n    }\r\n    float rGate(float x,float l){float a=smoothstep(0.0,W_AA,x),b=1.0-smoothstep(l,l+W_AA,x);return max(0.0,a*b);}\r\n    float flareY(float y){float t=clamp(1.0-(clamp(y,0.0,FLARE_HEIGHT)/max(FLARE_HEIGHT,EPS)),0.0,1.0);return pow(t,FLARE_EXP);}\r\n\r\n    float vWisps(vec2 uv,float topF){\r\n    float y=uv.y,yf=(y+uFlowTime*uWSpeed)/W_CELL;\r\n    float dRaw=clamp(uWispDensity,0.0,2.0),d=dRaw<=0.0?1.0:dRaw;\r\n    float lanesF=floor(float(W_LANES)*min(d,1.0)+0.5); // WebGL1-safe\r\n    int lanes=int(max(1.0,lanesF));\r\n    float sp=min(d,1.0),ep=max(d-1.0,0.0);\r\n    float fm=flareY(max(y,0.0)),rm=clamp(1.0-(y/max(W_CURVE_RANGE,EPS)),0.0,1.0),cm=fm*rm;\r\n    const float G=0.05; float xS=1.0+(FLARE_AMOUNT*W_CURVE_AMOUNT*G)*cm;\r\n    float sPix=clamp(y/R_V,0.0,1.0),bGain=pow(1.0-sPix,W_BOTTOM_EXP),sum=0.0;\r\n    for(int s=0;s<2;++s){\r\n        float sgn=s==0?-1.0:1.0;\r\n        for(int i=0;i<W_LANES;++i){\r\n            if(i>=lanes) break;\r\n            float off=W_BASE_X+float(i)*W_LAYER_GAP,xc=sgn*(off*xS);\r\n            float dx=abs(uv.x-xc),lat=1.0-smoothstep(W_HALF,W_HALF+W_AA,dx),amp=exp(-off*W_SIDE_DECAY);\r\n            float seed=h21(vec2(off,sgn*17.0)),yf2=yf+seed*7.0,ci=floor(yf2),fy=fract(yf2);\r\n            float seg=mix(W_SEG_MIN,W_SEG_MAX,h21(vec2(ci,off*2.3)));\r\n            float spR=h21(vec2(ci,off+sgn*31.0)),seg1=rGate(fy,seg)*step(spR,sp);\r\n            if(ep>0.0){float spR2=h21(vec2(ci*3.1+7.0,off*5.3+sgn*13.0)); float f2=fract(fy+0.5); seg1+=rGate(f2,seg*0.9)*step(spR2,ep);}\r\n            sum+=amp*lat*seg1;\r\n        }\r\n    }\r\n    float span=smoothstep(-3.0,0.0,y)*(1.0-smoothstep(R_V-6.0,R_V,y));\r\n    return uWIntensity*sum*topF*bGain*span;\r\n}\r\n\r\nvoid mainImage(out vec4 fc,in vec2 frag){\r\n    vec2 C=iResolution.xy*.5; float invW=1.0/max(C.x,1.0);\r\n    float sc=512.0/iResolution.x*.4;\r\n    vec2 uv=(frag-C)*sc,off=vec2(uBeamXFrac*iResolution.x*sc,uBeamYFrac*iResolution.y*sc);\r\n    vec2 uvc = uv - off;\r\n    float a=0.0,b=0.0;\r\n    float basePhase=1.5*PI+uDecay*.5; float tauMin=basePhase-uDecay; float tauMax=basePhase;\r\n    float cx=clamp(uvc.x/(R_H*uHLenFactor),-1.0,1.0),tH=clamp(TWO_PI-acos(cx),tauMin,tauMax);\r\n    for(int k=-TAP_RADIUS;k<=TAP_RADIUS;++k){\r\n        float tu=tH+float(k)*DT_LOCAL,wt=tauWf(tu,tauMin,tauMax); if(wt<=0.0) continue;\r\n        float spd=max(abs(sin(tu)),0.02),u=clamp((basePhase-tu)/max(uDecay,EPS),0.0,1.0),env=pow(1.0-abs(u*2.0-1.0),0.8);\r\n        vec2 p=vec2((R_H*uHLenFactor)*cos(tu),0.0);\r\n        a+=wt*bs(uvc,p,env*spd);\r\n    }\r\n    float yPix=uvc.y,cy=clamp(-yPix/(R_V*uVLenFactor),-1.0,1.0),tV=clamp(TWO_PI-acos(cy),tauMin,tauMax);\r\n    for(int k=-TAP_RADIUS;k<=TAP_RADIUS;++k){\r\n        float tu=tV+float(k)*DT_LOCAL,wt=tauWf(tu,tauMin,tauMax); if(wt<=0.0) continue;\r\n        float yb=(-R_V)*cos(tu),s=clamp(yb/R_V,0.0,1.0),spd=max(abs(sin(tu)),0.02);\r\n        float env=pow(1.0-s,0.6)*spd;\r\n        float cap=1.0-smoothstep(TOP_FADE_START,1.0,s); cap=pow(cap,TOP_FADE_EXP); env*=cap;\r\n        float ph=s/max(FLOW_PERIOD,EPS)+uFlowTime*uFlowSpeed;\r\n        float fl=pow(tri01(ph),FLOW_SHARPNESS);\r\n        env*=mix(1.0-uFlowStrength,1.0,fl);\r\n        float yp=(-R_V*uVLenFactor)*cos(tu),m=pow(smoothstep(FLARE_HEIGHT,0.0,yp),FLARE_EXP),wx=1.0+FLARE_AMOUNT*m;\r\n        vec2 sig=vec2(wx,1.0),p=vec2(0.0,yp);\r\n        float mask=step(0.0,yp);\r\n        b+=wt*bsa(uvc,p,mask*env,sig);\r\n    }\r\n    float sPix=clamp(yPix/R_V,0.0,1.0),topA=pow(1.0-smoothstep(TOP_FADE_START,1.0,sPix),TOP_FADE_EXP);\r\n    float L=a+b*topA;\r\n    float w=vWisps(vec2(uvc.x,yPix),topA);\r\n    float fog=0.0;\r\n#if FOG_ON\r\n    vec2 fuv=uvc*uFogScale;\r\n    float mAct=step(1.0,length(iMouse.xy)),nx=((iMouse.x-C.x)*invW)*mAct;\r\n    float ax = abs(nx);\r\n    float stMag = mix(ax, pow(ax, FOG_TILT_SHAPE), 0.35);\r\n    float st = sign(nx) * stMag * uTiltScale;\r\n    st = clamp(st, -FOG_TILT_MAX_X, FOG_TILT_MAX_X);\r\n    vec2 dir=normalize(vec2(st,1.0));\r\n    fuv+=uFogTime*uFogFallSpeed*dir;\r\n    vec2 prp=vec2(-dir.y,dir.x);\r\n    fuv+=prp*(0.08*sin(dot(uvc,prp)*0.08+uFogTime*0.9));\r\n    float n=fbm2(fuv+vec2(fbm2(fuv+vec2(7.3,2.1)),fbm2(fuv+vec2(-3.7,5.9)))*0.6);\r\n    n=pow(clamp(n,0.0,1.0),FOG_CONTRAST);\r\n    float pixW = 1.0 / max(iResolution.y, 1.0);\r\n#ifdef GL_OES_standard_derivatives\r\n    float wL = max(fwidth(L), pixW);\r\n#else\r\n    float wL = pixW;\r\n#endif\r\n    float m0=pow(smoothstep(FOG_BEAM_MIN - wL, FOG_BEAM_MAX + wL, L),FOG_MASK_GAMMA);\r\n    float bm=1.0-pow(1.0-m0,FOG_EXPAND_SHAPE); bm=mix(bm*m0,bm,FOG_EDGE_MIX);\r\n    float yP=1.0-smoothstep(HFOG_Y_RADIUS,HFOG_Y_RADIUS+HFOG_Y_SOFT,abs(yPix));\r\n    float nxF=abs((frag.x-C.x)*invW),hE=1.0-smoothstep(HFOG_EDGE_START,HFOG_EDGE_END,nxF); hE=pow(clamp(hE,0.0,1.0),HFOG_EDGE_GAMMA);\r\n    float hW=mix(1.0,hE,clamp(yP,0.0,1.0));\r\n    float bBias=mix(1.0,1.0-sPix,FOG_BOTTOM_BIAS);\r\n    fog=n*uFogIntensity*bBias*bm*hW;\r\n#endif\r\n    float LF=L+fog;\r\n    float dith=(h21(frag)-0.5)*(DITHER_STRENGTH/255.0);\r\n    float tone=g(LF+w);\r\n    vec3 col=tone*uColor+dith;\r\n    float alpha=clamp(g(L+w*0.6)+dith*0.6,0.0,1.0);\r\n    float nxE=abs((frag.x-C.x)*invW),xF=pow(clamp(1.0-smoothstep(EDGE_X0,EDGE_X1,nxE),0.0,1.0),EDGE_X_GAMMA);\r\n    float scene=LF+max(0.0,w)*0.5,hi=smoothstep(EDGE_LUMA_T0,EDGE_LUMA_T1,scene);\r\n    float eM=mix(xF,1.0,hi);\r\n    col*=eM; alpha*=eM;\r\n    col*=uFade; alpha*=uFade;\r\n    fc=vec4(col,alpha);\r\n}\r\n\r\nvoid main(){\r\n  vec4 fc;\r\n  mainImage(fc, gl_FragCoord.xy);\r\n  gl_FragColor = fc;\r\n}\r\n`;\r\n\r\nexport const LaserFlow: React.FC<Props> = ({\r\n  className,\r\n  style,\r\n  wispDensity = 1,\r\n  dpr,\r\n  mouseSmoothTime = 0.0,\r\n  mouseTiltStrength = 0.01,\r\n  horizontalBeamOffset = 0.1,\r\n  verticalBeamOffset = 0.0,\r\n  flowSpeed = 0.35,\r\n  verticalSizing = 2.0,\r\n  horizontalSizing = 0.5,\r\n  fogIntensity = 0.45,\r\n  fogScale = 0.3,\r\n  wispSpeed = 15.0,\r\n  wispIntensity = 5.0,\r\n  flowStrength = 0.25,\r\n  decay = 1.1,\r\n  falloffStart = 1.2,\r\n  fogFallSpeed = 0.6,\r\n  color = '#FF79C6'\r\n}) => {\r\n  const mountRef = useRef<HTMLDivElement | null>(null);\r\n  const hasFadedRef = useRef(false);\r\n\r\n  useEffect(() => {\r\n    const mount = mountRef.current!;\r\n    const renderer = new THREE.WebGLRenderer({\r\n      antialias: true,\r\n      alpha: false,\r\n      powerPreference: 'high-performance',\r\n      premultipliedAlpha: false\r\n    });\r\n    renderer.setClearColor(0x000000, 1);\r\n    renderer.domElement.style.width = '100%';\r\n    renderer.domElement.style.height = '100%';\r\n    renderer.domElement.style.display = 'block';\r\n    mount.appendChild(renderer.domElement);\r\n\r\n    const scene = new THREE.Scene();\r\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\r\n\r\n    const geometry = new THREE.BufferGeometry();\r\n    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), 3));\r\n\r\n    const uniforms = {\r\n      iTime: { value: 0 },\r\n      iResolution: { value: new THREE.Vector3(1, 1, 1) },\r\n      iMouse: { value: new THREE.Vector4(0, 0, 0, 0) },\r\n      uWispDensity: { value: wispDensity },\r\n      uTiltScale: { value: mouseTiltStrength },\r\n      uFlowTime: { value: 0 },\r\n      uFogTime: { value: 0 },\r\n      uBeamXFrac: { value: horizontalBeamOffset },\r\n      uBeamYFrac: { value: verticalBeamOffset },\r\n      uFlowSpeed: { value: flowSpeed },\r\n      uVLenFactor: { value: verticalSizing },\r\n      uHLenFactor: { value: horizontalSizing },\r\n      uFogIntensity: { value: fogIntensity },\r\n      uFogScale: { value: fogScale },\r\n      uWSpeed: { value: wispSpeed },\r\n      uWIntensity: { value: wispIntensity },\r\n      uFlowStrength: { value: flowStrength },\r\n      uDecay: { value: decay },\r\n      uFalloffStart: { value: falloffStart },\r\n      uFogFallSpeed: { value: fogFallSpeed },\r\n      uColor: { value: new THREE.Vector3(1, 1, 1) },\r\n      uFade: { value: hasFadedRef.current ? 1 : 0 }\r\n    };\r\n\r\n    const material = new THREE.RawShaderMaterial({\r\n      vertexShader: VERT,\r\n      fragmentShader: FRAG,\r\n      uniforms,\r\n      transparent: false,\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      blending: THREE.NormalBlending\r\n    });\r\n\r\n    const mesh = new THREE.Mesh(geometry, material);\r\n    scene.add(mesh);\r\n\r\n    const clock = new THREE.Clock();\r\n    let prevTime = 0;\r\n    let flowTime = 0;\r\n    let fogTime = 0;\r\n    let fade = hasFadedRef.current ? 1 : 0;\r\n    const mouseTarget = new THREE.Vector2(0, 0);\r\n    const mouseSmooth = new THREE.Vector2(0, 0);\r\n\r\n    const setSize = () => {\r\n      const { clientWidth: w, clientHeight: h } = mount;\r\n      const pixelRatio = Math.min(dpr ?? window.devicePixelRatio ?? 1, 2);\r\n      renderer.setPixelRatio(pixelRatio);\r\n      renderer.setSize(w, h, false);\r\n      uniforms.iResolution.value.set(w * pixelRatio, h * pixelRatio, pixelRatio);\r\n    };\r\n\r\n    setSize();\r\n    const ro = new ResizeObserver(setSize);\r\n    ro.observe(mount);\r\n\r\n    const updateMouse = (clientX: number, clientY: number) => {\r\n      const rect = renderer.domElement.getBoundingClientRect();\r\n      const x = clientX - rect.left;\r\n      const y = clientY - rect.top;\r\n      const ratio = renderer.getPixelRatio();\r\n      const hb = rect.height * ratio;\r\n      mouseTarget.set(x * ratio, hb - y * ratio);\r\n    };\r\n\r\n    const onMove = (ev: PointerEvent | MouseEvent) => updateMouse(ev.clientX, ev.clientY);\r\n    const onLeave = () => mouseTarget.set(0, 0);\r\n\r\n    renderer.domElement.addEventListener('pointermove', onMove as any);\r\n    renderer.domElement.addEventListener('pointerdown', onMove as any);\r\n    renderer.domElement.addEventListener('pointerenter', onMove as any);\r\n    renderer.domElement.addEventListener('pointerleave', onLeave as any);\r\n    window.addEventListener('mousemove', onMove);\r\n\r\n    let raf = 0;\r\n    const animate = () => {\r\n      const t = clock.getElapsedTime();\r\n      const dt = Math.max(0, t - prevTime);\r\n      prevTime = t;\r\n      uniforms.iTime.value = t;\r\n      uniforms.uTiltScale.value = mouseTiltStrength;\r\n      uniforms.uWispDensity.value = wispDensity;\r\n      uniforms.uBeamXFrac.value = horizontalBeamOffset;\r\n      uniforms.uBeamYFrac.value = verticalBeamOffset;\r\n      uniforms.uFlowSpeed.value = flowSpeed;\r\n      uniforms.uVLenFactor.value = verticalSizing;\r\n      uniforms.uHLenFactor.value = horizontalSizing;\r\n      uniforms.uFogIntensity.value = fogIntensity;\r\n      uniforms.uFogScale.value = fogScale;\r\n      uniforms.uWSpeed.value = wispSpeed;\r\n      uniforms.uWIntensity.value = wispIntensity;\r\n      uniforms.uFlowStrength.value = flowStrength;\r\n      uniforms.uDecay.value = decay;\r\n      uniforms.uFalloffStart.value = falloffStart;\r\n      uniforms.uFogFallSpeed.value = fogFallSpeed;\r\n      (function () {\r\n        let c = color || '#ffffff';\r\n        c = c.trim();\r\n        if (c[0] === '#') c = c.slice(1);\r\n        if (c.length === 3)\r\n          c = c\r\n            .split('')\r\n            .map(x => x + x)\r\n            .join('');\r\n        let n = parseInt(c, 16);\r\n        if (isNaN(n)) n = 0xffffff;\r\n        const r = ((n >> 16) & 255) / 255;\r\n        const g = ((n >> 8) & 255) / 255;\r\n        const b = (n & 255) / 255;\r\n        uniforms.uColor.value.set(r, g, b);\r\n      })();\r\n      const cdt = Math.min(0.033, Math.max(0.001, dt));\r\n      flowTime += cdt;\r\n      fogTime += cdt;\r\n      uniforms.uFlowTime.value = flowTime;\r\n      uniforms.uFogTime.value = fogTime;\r\n      if (!hasFadedRef.current) {\r\n        const fadeDur = 1.0;\r\n        fade = Math.min(1, fade + cdt / fadeDur);\r\n        uniforms.uFade.value = fade;\r\n        if (fade >= 1) hasFadedRef.current = true;\r\n      } else if (uniforms.uFade.value !== 1) {\r\n        uniforms.uFade.value = 1;\r\n      }\r\n\r\n      const tau = Math.max(1e-3, mouseSmoothTime);\r\n      const alpha = 1 - Math.exp(-cdt / tau);\r\n      mouseSmooth.lerp(mouseTarget, alpha);\r\n      uniforms.iMouse.value.set(mouseSmooth.x, mouseSmooth.y, 0, 0);\r\n\r\n      renderer.render(scene, camera);\r\n      raf = requestAnimationFrame(animate);\r\n    };\r\n    animate();\r\n\r\n    return () => {\r\n      cancelAnimationFrame(raf);\r\n      ro.disconnect();\r\n      renderer.domElement.removeEventListener('pointermove', onMove as any);\r\n      renderer.domElement.removeEventListener('pointerdown', onMove as any);\r\n      renderer.domElement.removeEventListener('pointerenter', onMove as any);\r\n      renderer.domElement.removeEventListener('pointerleave', onLeave as any);\r\n      window.removeEventListener('mousemove', onMove);\r\n      geometry.dispose();\r\n      material.dispose();\r\n      renderer.dispose();\r\n      mount.removeChild(renderer.domElement);\r\n    };\r\n  }, [\r\n    wispDensity,\r\n    dpr,\r\n    mouseSmoothTime,\r\n    mouseTiltStrength,\r\n    horizontalBeamOffset,\r\n    verticalBeamOffset,\r\n    flowSpeed,\r\n    verticalSizing,\r\n    horizontalSizing,\r\n    fogIntensity,\r\n    fogScale,\r\n    wispSpeed,\r\n    wispIntensity,\r\n    flowStrength,\r\n    decay,\r\n    falloffStart,\r\n    fogFallSpeed,\r\n    color\r\n  ]);\r\n\r\n  return <div ref={mountRef} className={`w-full h-full relative ${className}`} style={style} />;\r\n};\r\n\r\nexport default LaserFlow;\r\n",
    },
  },
};
